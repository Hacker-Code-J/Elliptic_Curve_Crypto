\chapter{NIST secp256k1}
\iffalse
\section{Time Measure in Linux}

\begin{lstlisting}[style=C]
#define _POSIX_C_SOURCE 200809L
#include <time.h>

typedef int8_t i8;
typedef int32_t i32;
typedef int64_t i64;

typedef uint8_t u8;
typedef uint32_t u32;
typedef uint64_t u64;

inline u64 rdtsc(void) {
	u32 lo, hi;
	
	__asm__ __volatile__ (
	"rdtsc" : "=a" (lo), "=d" (hi)
	);
	
	return ((u64)hi << 32) | lo;
}

u64 measure_cycle(void (*func)(u8*, u8*), u8* para1, u8* para2) {
	u64 start, end;
	const u64 num_runs = 10000;
	
	func(para1, para2);
	start = rdtsc();
	for (i32 i = 0; i < num_runs; i++)
		func(para1, para2);
	end = rdtsc();
	
	return (end - start) / num_runs;
}

double measure_time(void (*func)(u8*, u8*), u8* para1, u8* para2) {
	struct timespec start, end;
	double cpu_time_used;
	const double num_runs = 10000;
	
	func(para1, para2);
	clock_gettime(CLOCK_MONOTONIC, &start);
	for (i32 i = 0; i < num_runs; i++)
		func(para1, para2);
	clock_gettime(CLOCK_MONOTONIC, &end);
	
	cpu_time_used =
		(end.tv_sec - start.tv_sec) +
		(end.tv_nsec - start.tv_nsec) / 1e9;
	
	return cpu_time_used / num_runs;
}
\end{lstlisting}
\fi
\section{Data Representation}

\begin{table}[h!]\centering\renewcommand{\arraystretch}{1.25} % Increase row height by 1.5 times
	\begin{tabular}{@{\extracolsep{\fill}}>{\bfseries}l||c|c|c|c|c|c|c|c|c|c|c|c}
		\toprule[1.2pt]
		128-bit Hexa-string & \multicolumn{12}{c}{\texttt{0x77FDDC58464B01FC6606BC465BF5CBCB}} \\
		\hline
		String Index & \cellcolor{red!20}0 & \cellcolor{red!20}$\cdots$ & \cellcolor{red!20}7 & \cellcolor{green!20}8 & \cellcolor{green!20}$\cdots$ & \cellcolor{green!20}15 & \cellcolor{blue!20}16 & \cellcolor{blue!20}$\cdots$ & \cellcolor{blue!20}23 & \cellcolor{orange!20}24 & \cellcolor{orange!20}$\cdots$ & \cellcolor{orange!20}31 \\
		\hline
		\multirow{2}{*}{Split into Words} & \multicolumn{3}{c}{\texttt{77FDDC58}} & \multicolumn{3}{c}{\texttt{464B01FC}} & \multicolumn{3}{c}{\texttt{6606BC46}} & \multicolumn{3}{c}{\texttt{5BF5CBCB}} \\
		& \multicolumn{3}{c}{$\data[3]$} & \multicolumn{3}{c}{$\data[2]$} & \multicolumn{3}{c}{$\data[1]$} & \multicolumn{3}{c}{$\data[0]$}\\
		\hline
		\multirow{4}{*}{$\data[0]$} & \multicolumn{12}{c}{\texttt{(data[0] = '5'-'0';)} -> \texttt{(data[0]} $\ll=$ 4;)} \\
		& \multicolumn{12}{c}{-> \texttt{(data[0] |= 'B'-'0';)} -> \texttt{(data[0]} $\ll=$ 4;)}\\
		& \multicolumn{12}{c}{-> \texttt{(data[0] |= 'F'-'0';)} -> $\cdots$}\\
		\cline{2-13}
		& \multicolumn{12}{c}{\texttt{0x5 -> 0x50 -> 0x5B -> 0x5B0 -> $\cdots$}}\\
		\bottomrule[1.2pt]
	\end{tabular}
\end{table}
\begin{lstlisting}[style=C]
void stringToWord(u32* wordArray, const char hexString[]) {
	size_t length = strlen(hexString) / 8; // 64 / 8 = 8

	for (size_t i = 0; i < length; i++)
		sscanf(&hexString[i], "%8X", &wordArray[(length-1) - i]);
}
\end{lstlisting}
\begin{lstlisting}[style=C]
int main(void) {
	const char string[] =
	"BD91C935C85617B079C6F2728B987CE4
	 88BB17B4644D5F8B9C23AF955AB74663";
	
	u32 data[8];
	stringToWord(data, string);
	
	for (i32 i = 7; i >=0; i--)
		printf("%8X:", data[i]);
	
	return 0;
}
\end{lstlisting}
\begin{lstlisting}[style=zsh]
BD91C935:D91C935C:91C935C8:1C935C85:
C935C856:935C8561:35C85617:5C85617B:
\end{lstlisting}

\newpage
\begin{example}[secp256k1]
Consider $p = 2^{256} - 2^{32} - 2^{9} - 2^{8} - 2^7 - 2^6 - 2^4 - 1$.
\begin{table}[h!]\centering\renewcommand{\arraystretch}{1.25}
{\ttfamily\footnotesize\begin{tabular*}{\textwidth}{@{\extracolsep{\fill}}ccccccccc}
		$2^{256}$ &  10000000 & 00000000 & 00000000 & 00000000 & 00000000 & 00000000 & 00000000 & 00000000\\
		$-2^{32}$ & & & & & & & & 10000000 \\
		$-2^{9}$ & & & & & & & & 00000200 \\
		$-2^{8}$ & & & & & & & & 00000100 \\
		$-2^{7}$ & & & & & & & & 00000080 \\
		$-2^{6}$ & & & & & & & & 00000040 \\
		$-2^{4}$ & & & & & & & & 00000010 \\
		$-2^{0}$ & & & & & & & & 00000001 \\ \cline{1-9}
		$p$ & FFFFFFFF & FFFFFFFF & FFFFFFFF & FFFFFFFF & FFFFFFFF & FFFFFFFF & FFFFFFFE & FFFFFC2F \\
\end{tabular*}}
\end{table}
\begin{lstlisting}[style=C]
u32 prime[8] = {
	0xFFFFFC2F, 0xFFFFFFFE, 0xFFFFFFFF, 0xFFFFFFFF,
	0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF
};
\end{lstlisting}
\end{example}

\section{secp256k1}
Define a prime number \begin{align*}
p_{256} &= 2^{256}-2^{224}+2^{192}+2^{96}-1 \\
&=2^{32*8}-2^{32*7}+2^{32*6}+2^{32*3}-2^{32*0}\\
&= 2^{64*4}-2^{64*(7/2)}+2^{64*3}+2^{64*(3/2)}-2^{64*0}
\end{align*} that is used in the context of cryptography, particularly in the construction of elliptic curves for cryptographic purposes.
For prime $p$, let \begin{align*}
	m = \ceil*{\log_2 p},\quad t=\ceil*{\frac{m}{W}}.
\end{align*} For example, for $p=2^{256}$, we have $t=\ceil*{\frac{\ceil{\log_2 2^{256}}}{2^{32}}}$. Note that \begin{itemize}
\item $A = A[t-1]\adjacent\cdots\adjacent A[2]\adjacent A[1]\adjacent A[0]$
\item $a = 2^{(t-1)W}A[t-1]$+$\cdots 2^{2W}A[2]+2^{W}A[1]+A[0]$
\end{itemize}

\newpage

\vspace{4pt}
\begin{lstlisting}[style=C]
#ifdef _64BIT_SYSTEM
typedef u64 field_element[4]; // For 64-bit systems
#else
typedef u32 field_element[8]; // For 32-bit systems
#endif

// Example for modular addition (simplified)
void mod_add(field_element a, field_element b, field_element result) {
	uint64_t carry = 0;
	for (int i = 0; i < 4; ++i) { // Assuming 64-bit system
		uint64_t temp = (uint64_t)a[i] + b[i] + carry;
		result[i] = temp & 0xFFFFFFFFFFFFFFFF; // Keep only 64 bits
		carry = temp >> 64; // Carry for the next iteration
	}
	
	// Modular reduction if necessary
	if (carry || is_greater_or_equal(result, p256)) {
		// Subtract p256 if result >= p256
		subtract_p256(result);
	}
}

void subtract_p256(field_element x) {
	// This is a simplified version. In practice, you'd need to handle underflows.
	// Subtract (2^256 - 2^224 + 2^192 + 2^96 - 1)
	// In practice, implement this function based on the specific structure of p256
	// and considering the binary representation of the field elements.
}
\end{lstlisting}

\newpage
\section{Multi-precision Addition}

\begin{algorithm}[H]
	\DontPrintSemicolon
	\caption{Multi-Precision Addition}
	\KwIn{$u,v\intco{0,2^{Wt}}\subseteq\Z$}
	\KwOut{$(\varepsilon,Z)$ where $Z=X+Y\bmod 2^{Wt}$ and $\varepsilon\in\set{0,1}$ is carry bit}
	\BlankLine
	$(\varepsilon,z[0])\gets x[0]+y[0]$\;
	\For{$i=1$ \KwTo $t-1$}{
		$(\varepsilon,z[i])\gets x[i] + y[i] + \varepsilon$\;
	}
	\Return $(\varepsilon, Z=z[t-1]\adjacent z[t-2]\adjacent\cdots\adjacent z[0])$\;
\end{algorithm}
\begin{example}
\ \begin{table}[h!]\centering\renewcommand{\arraystretch}{1.25}
	{\ttfamily\begin{tabular*}{\textwidth}{@{\extracolsep{\fill}}cccccc}
	$X$ & & 0xFFFFFFFF & 0xFFFFFFFF & 0xFFFFFFFF & 0xFFFFFFFF \\
	$Y$ & + & 0xFFFFFFFF & 0xFFFFFFFF & 0xFFFFFFFF & 0xFFFFFFFF \\
	$\varepsilon$ & 1 & 1 & 1 & 1 & 0 \\ \cline{2-6}
	$Z$ & 0x00000001 & 0xFFFFFFFF & 0xFFFFFFFF & 0xFFFFFFFF & 0xFFFFFFFE \\
	\end{tabular*}}
\end{table}
\end{example}

\begin{note}[How to Compute Carry?]
	content...
\end{note}


