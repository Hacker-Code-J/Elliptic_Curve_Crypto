\chapter{Prime Field Operations}
\iffalse
\section{Time Measure in Linux}

\begin{lstlisting}[style=C]
#define _POSIX_C_SOURCE 200809L
#include <time.h>

typedef int8_t i8;
typedef int32_t i32;
typedef int64_t i64;

typedef uint8_t u8;
typedef uint32_t u32;
typedef uint64_t u64;

inline u64 rdtsc(void) {
	u32 lo, hi;
	
	__asm__ __volatile__ (
	"rdtsc" : "=a" (lo), "=d" (hi)
	);
	
	return ((u64)hi << 32) | lo;
}

u64 measure_cycle(void (*func)(u8*, u8*), u8* para1, u8* para2) {
	u64 start, end;
	const u64 num_runs = 10000;
	
	func(para1, para2);
	start = rdtsc();
	for (i32 i = 0; i < num_runs; i++)
		func(para1, para2);
	end = rdtsc();
	
	return (end - start) / num_runs;
}

double measure_time(void (*func)(u8*, u8*), u8* para1, u8* para2) {
	struct timespec start, end;
	double cpu_time_used;
	const double num_runs = 10000;
	
	func(para1, para2);
	clock_gettime(CLOCK_MONOTONIC, &start);
	for (i32 i = 0; i < num_runs; i++)
		func(para1, para2);
	clock_gettime(CLOCK_MONOTONIC, &end);
	
	cpu_time_used =
		(end.tv_sec - start.tv_sec) +
		(end.tv_nsec - start.tv_nsec) / 1e9;
	
	return cpu_time_used / num_runs;
}
\end{lstlisting}
\fi
\section{Data Representation}

\begin{table}[h!]\centering\renewcommand{\arraystretch}{1.25} % Increase row height by 1.5 times
	\begin{tabular}{@{\extracolsep{\fill}}>{\bfseries}l||c|c|c|c|c|c|c|c|c|c|c|c}
		\toprule[1.2pt]
		128-bit Input String & \multicolumn{12}{c}{\texttt{0x77FDDC58464B01FC6606BC465BF5CBCB}} \\
		\hline
		String Index & \cellcolor{red!20}0 & \cellcolor{red!20}$\cdots$ & \cellcolor{red!20}7 & \cellcolor{green!20}8 & \cellcolor{green!20}$\cdots$ & \cellcolor{green!20}15 & \cellcolor{blue!20}16 & \cellcolor{blue!20}$\cdots$ & \cellcolor{blue!20}23 & \cellcolor{orange!20}24 & \cellcolor{orange!20}$\cdots$ & \cellcolor{orange!20}31 \\
		\hline
		\multirow{2}{*}{Split into Words} & \multicolumn{3}{c}{\texttt{77FDDC58}} & \multicolumn{3}{c}{\texttt{464B01FC}} & \multicolumn{3}{c}{\texttt{6606BC46}} & \multicolumn{3}{c}{\texttt{5BF5CBCB}} \\
		& \multicolumn{3}{c}{$\data[3]$} & \multicolumn{3}{c}{$\data[2]$} & \multicolumn{3}{c}{$\data[1]$} & \multicolumn{3}{c}{$\data[0]$}\\
		\hline
		\multirow{4}{*}{$\data[0]$} & \multicolumn{12}{c}{\texttt{(data[0] = '5'-'0';)} -> \texttt{(data[0]} $\ll=$ 4;)} \\
		& \multicolumn{12}{c}{-> \texttt{(data[0] |= 'B'-'0';)} -> \texttt{(data[0]} $\ll=$ 4;)}\\
		& \multicolumn{12}{c}{-> \texttt{(data[0] |= 'F'-'0';)} -> $\cdots$}\\
		\cline{2-13}
		& \multicolumn{12}{c}{\texttt{0x5 -> 0x50 -> 0x5B -> 0x5B0 -> $\cdots$}}\\
		\bottomrule[1.2pt]
	\end{tabular}
\end{table}

\section{NIST P256}
Define a prime number \begin{align*}
p_{256} &= 2^{256}-2^{224}+2^{192}+2^{96}-1 \\
&=2^{32*8}-2^{32*7}+2^{32*6}+2^{32*3}-2^{32*0}\\
&= 2^{64*4}-2^{64*(7/2)}+2^{64*3}+2^{64*(3/2)}-2^{64*0}
\end{align*} that is used in the context of cryptography, particularly in the construction of elliptic curves for cryptographic purposes.
For prime $p$, let \begin{align*}
	m = \ceil*{\log_2 p},\quad t=\ceil*{\frac{m}{W}}.
\end{align*} For example, for $p=2^{256}$, we have $t=\ceil*{\frac{\ceil{\log_2 2^{256}}}{2^{32}}}$. Note that \begin{itemize}
\item $A = A[t-1]\adjacent\cdots\adjacent A[2]\adjacent A[1]\adjacent A[0]$
\item $a = 2^{(t-1)W}A[t-1]$+$\cdots 2^{2W}A[2]+2^{W}A[1]+A[0]$
\end{itemize}

\begin{lstlisting}[style=C]
#ifdef _64BIT_SYSTEM
typedef u64 field_element[4]; // For 64-bit systems
#else
typedef u32 field_element[8]; // For 32-bit systems
#endif

// Example for modular addition (simplified)
void mod_add(field_element a, field_element b, field_element result) {
	uint64_t carry = 0;
	for (int i = 0; i < 4; ++i) { // Assuming 64-bit system
		uint64_t temp = (uint64_t)a[i] + b[i] + carry;
		result[i] = temp & 0xFFFFFFFFFFFFFFFF; // Keep only 64 bits
		carry = temp >> 64; // Carry for the next iteration
	}
	
	// Modular reduction if necessary
	if (carry || is_greater_or_equal(result, p256)) {
		// Subtract p256 if result >= p256
		subtract_p256(result);
	}
}

void subtract_p256(field_element x) {
	// This is a simplified version. In practice, you'd need to handle underflows.
	// Subtract (2^256 - 2^224 + 2^192 + 2^96 - 1)
	// In practice, implement this function based on the specific structure of p256
	// and considering the binary representation of the field elements.
}
\end{lstlisting}

\newpage
\section{Multi-precision Addition}

\begin{algorithm}[H]
	\DontPrintSemicolon
	\caption{Multi-Precision Addition}
	\KwIn{$u,v\intco{0,2^{Wt}}\subseteq\Z$}
	\KwOut{$(\varepsilon,w)$ where $w=u+v\bmod 2^{Wt}$ and $\varepsilon\in\set{0,1}$ is carry bit}
	\BlankLine
	$(\varepsilon,W[0])\gets U[0]+V[0]$\;
	\For{$i=1$ \KwTo $t-1$}{
		$(\varepsilon,W[i])\gets U[i] + V[i] + \varepsilon$\;
	}
	\Return $(\varepsilon, w)$\;
\end{algorithm}
\begin{example}
\ \begin{table}[h!]\centering\renewcommand{\arraystretch}{1.25}
	{\ttfamily\begin{tabular*}{\textwidth}{@{\extracolsep{\fill}}cccccc}
	$U$ & & 0xFFFFFFFF & 0xFFFFFFFF & 0xFFFFFFFF & 0xFFFFFFFF \\
	$V$ & + & 0xFFFFFFFF & 0xFFFFFFFF & 0xFFFFFFFF & 0xFFFFFFFF \\
	$\varepsilon$ & 1 & 1 & 1 & 1 & 0 \\ \cline{2-6}
	$W$ & 0x00000001 & 0xFFFFFFFF & 0xFFFFFFFF & 0xFFFFFFFF & 0xFFFFFFFE \\
	\end{tabular*}}
\end{table}	
\end{example}


